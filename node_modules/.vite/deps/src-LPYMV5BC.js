import {
  require_node_crypto,
  require_node_fs,
  require_node_os
} from "./chunk-TEHJSVVM.js";
import {
  require_node_path
} from "./chunk-DRPV7AK7.js";
import {
  __commonJS,
  __esm,
  __export,
  __toESM
} from "./chunk-S5KM4IGW.js";

// browser-external:node:events
var require_node_events = __commonJS({
  "browser-external:node:events"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:events" has been externalized for browser compatibility. Cannot access "node:events.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/formidable/src/PersistentFile.js
var import_node_fs, import_node_crypto, import_node_events, PersistentFile, PersistentFile_default;
var init_PersistentFile = __esm({
  "node_modules/formidable/src/PersistentFile.js"() {
    import_node_fs = __toESM(require_node_fs(), 1);
    import_node_crypto = __toESM(require_node_crypto(), 1);
    import_node_events = __toESM(require_node_events(), 1);
    PersistentFile = class extends import_node_events.EventEmitter {
      constructor({ filepath, newFilename, originalFilename, mimetype, hashAlgorithm }) {
        super();
        this.lastModifiedDate = null;
        Object.assign(this, { filepath, newFilename, originalFilename, mimetype, hashAlgorithm });
        this.size = 0;
        this._writeStream = null;
        if (typeof this.hashAlgorithm === "string") {
          this.hash = import_node_crypto.default.createHash(this.hashAlgorithm);
        } else {
          this.hash = null;
        }
      }
      open() {
        this._writeStream = import_node_fs.default.createWriteStream(this.filepath);
        this._writeStream.on("error", (err) => {
          this.emit("error", err);
        });
      }
      toJSON() {
        const json = {
          size: this.size,
          filepath: this.filepath,
          newFilename: this.newFilename,
          mimetype: this.mimetype,
          mtime: this.lastModifiedDate,
          length: this.length,
          originalFilename: this.originalFilename
        };
        if (this.hash && this.hash !== "") {
          json.hash = this.hash;
        }
        return json;
      }
      toString() {
        return `PersistentFile: ${this.newFilename}, Original: ${this.originalFilename}, Path: ${this.filepath}`;
      }
      write(buffer, cb) {
        if (this.hash) {
          this.hash.update(buffer);
        }
        if (this._writeStream.closed) {
          cb();
          return;
        }
        this._writeStream.write(buffer, () => {
          this.lastModifiedDate = new Date();
          this.size += buffer.length;
          this.emit("progress", this.size);
          cb();
        });
      }
      end(cb) {
        if (this.hash) {
          this.hash = this.hash.digest("hex");
        }
        this._writeStream.end(() => {
          this.emit("end");
          cb();
        });
      }
      destroy() {
        this._writeStream.destroy();
        const filepath = this.filepath;
        setTimeout(function() {
          import_node_fs.default.unlink(filepath, () => {
          });
        }, 1);
      }
    };
    PersistentFile_default = PersistentFile;
  }
});

// node_modules/formidable/src/VolatileFile.js
var import_node_crypto2, import_node_events2, VolatileFile, VolatileFile_default;
var init_VolatileFile = __esm({
  "node_modules/formidable/src/VolatileFile.js"() {
    import_node_crypto2 = __toESM(require_node_crypto(), 1);
    import_node_events2 = __toESM(require_node_events(), 1);
    VolatileFile = class extends import_node_events2.EventEmitter {
      constructor({ filepath, newFilename, originalFilename, mimetype, hashAlgorithm, createFileWriteStream }) {
        super();
        this.lastModifiedDate = null;
        Object.assign(this, { filepath, newFilename, originalFilename, mimetype, hashAlgorithm, createFileWriteStream });
        this.size = 0;
        this._writeStream = null;
        if (typeof this.hashAlgorithm === "string") {
          this.hash = (0, import_node_crypto2.createHash)(this.hashAlgorithm);
        } else {
          this.hash = null;
        }
      }
      open() {
        this._writeStream = this.createFileWriteStream(this);
        this._writeStream.on("error", (err) => {
          this.emit("error", err);
        });
      }
      destroy() {
        this._writeStream.destroy();
      }
      toJSON() {
        const json = {
          size: this.size,
          newFilename: this.newFilename,
          length: this.length,
          originalFilename: this.originalFilename,
          mimetype: this.mimetype
        };
        if (this.hash && this.hash !== "") {
          json.hash = this.hash;
        }
        return json;
      }
      toString() {
        return `VolatileFile: ${this.originalFilename}`;
      }
      write(buffer, cb) {
        if (this.hash) {
          this.hash.update(buffer);
        }
        if (this._writeStream.closed || this._writeStream.destroyed) {
          cb();
          return;
        }
        this._writeStream.write(buffer, () => {
          this.size += buffer.length;
          this.emit("progress", this.size);
          cb();
        });
      }
      end(cb) {
        if (this.hash) {
          this.hash = this.hash.digest("hex");
        }
        this._writeStream.end(() => {
          this.emit("end");
          cb();
        });
      }
    };
    VolatileFile_default = VolatileFile;
  }
});

// browser-external:node:string_decoder
var require_node_string_decoder = __commonJS({
  "browser-external:node:string_decoder"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:string_decoder" has been externalized for browser compatibility. Cannot access "node:string_decoder.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/hexoid/dist/index.mjs
function dist_default(len) {
  len = len || 16;
  var str = "", num = 0;
  return function() {
    if (!str || num === 256) {
      str = "";
      num = (1 + len) / 2 | 0;
      while (num--)
        str += HEX[256 * Math.random() | 0];
      str = str.substring(num = 0, len - 2);
    }
    return str + HEX[num++];
  };
}
var IDX, HEX;
var init_dist = __esm({
  "node_modules/hexoid/dist/index.mjs"() {
    IDX = 256;
    HEX = [];
    while (IDX--)
      HEX[IDX] = (IDX + 256).toString(16).substring(1);
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module) {
    module.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module) {
    var wrappy = require_wrappy();
    module.exports = wrappy(once2);
    module.exports.strict = wrappy(onceStrict);
    once2.proto = once2(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once2(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once2(fn) {
      var f2 = function() {
        if (f2.called)
          return f2.value;
        f2.called = true;
        return f2.value = fn.apply(this, arguments);
      };
      f2.called = false;
      return f2;
    }
    function onceStrict(fn) {
      var f2 = function() {
        if (f2.called)
          throw new Error(f2.onceError);
        f2.called = true;
        return f2.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f2.onceError = name + " shouldn't be called more than once";
      f2.called = false;
      return f2;
    }
  }
});

// node_modules/asap/browser-raw.js
var require_browser_raw = __commonJS({
  "node_modules/asap/browser-raw.js"(exports, module) {
    "use strict";
    module.exports = rawAsap;
    function rawAsap(task) {
      if (!queue.length) {
        requestFlush();
        flushing = true;
      }
      queue[queue.length] = task;
    }
    var queue = [];
    var flushing = false;
    var requestFlush;
    var index = 0;
    var capacity = 1024;
    function flush() {
      while (index < queue.length) {
        var currentIndex = index;
        index = index + 1;
        queue[currentIndex].call();
        if (index > capacity) {
          for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
            queue[scan] = queue[scan + index];
          }
          queue.length -= index;
          index = 0;
        }
      }
      queue.length = 0;
      index = 0;
      flushing = false;
    }
    var scope = typeof global !== "undefined" ? global : self;
    var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
    if (typeof BrowserMutationObserver === "function") {
      requestFlush = makeRequestCallFromMutationObserver(flush);
    } else {
      requestFlush = makeRequestCallFromTimer(flush);
    }
    rawAsap.requestFlush = requestFlush;
    function makeRequestCallFromMutationObserver(callback) {
      var toggle = 1;
      var observer = new BrowserMutationObserver(callback);
      var node = document.createTextNode("");
      observer.observe(node, { characterData: true });
      return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
      };
    }
    function makeRequestCallFromTimer(callback) {
      return function requestCall() {
        var timeoutHandle = setTimeout(handleTimer, 0);
        var intervalHandle = setInterval(handleTimer, 50);
        function handleTimer() {
          clearTimeout(timeoutHandle);
          clearInterval(intervalHandle);
          callback();
        }
      };
    }
    rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;
  }
});

// node_modules/asap/browser-asap.js
var require_browser_asap = __commonJS({
  "node_modules/asap/browser-asap.js"(exports, module) {
    "use strict";
    var rawAsap = require_browser_raw();
    var freeTasks = [];
    var pendingErrors = [];
    var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);
    function throwFirstError() {
      if (pendingErrors.length) {
        throw pendingErrors.shift();
      }
    }
    module.exports = asap;
    function asap(task) {
      var rawTask;
      if (freeTasks.length) {
        rawTask = freeTasks.pop();
      } else {
        rawTask = new RawTask();
      }
      rawTask.task = task;
      rawAsap(rawTask);
    }
    function RawTask() {
      this.task = null;
    }
    RawTask.prototype.call = function() {
      try {
        this.task.call();
      } catch (error) {
        if (asap.onerror) {
          asap.onerror(error);
        } else {
          pendingErrors.push(error);
          requestErrorThrow();
        }
      } finally {
        this.task = null;
        freeTasks[freeTasks.length] = this;
      }
    };
  }
});

// node_modules/dezalgo/dezalgo.js
var require_dezalgo = __commonJS({
  "node_modules/dezalgo/dezalgo.js"(exports, module) {
    var wrappy = require_wrappy();
    module.exports = wrappy(dezalgo2);
    var asap = require_browser_asap();
    function dezalgo2(cb) {
      var sync = true;
      asap(function() {
        sync = false;
      });
      return function zalgoSafe() {
        var args = arguments;
        var me = this;
        if (sync)
          asap(function() {
            cb.apply(me, args);
          });
        else
          cb.apply(me, args);
      };
    }
  }
});

// browser-external:node:stream
var require_node_stream = __commonJS({
  "browser-external:node:stream"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:stream" has been externalized for browser compatibility. Cannot access "node:stream.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/formidable/src/parsers/OctetStream.js
var import_node_stream, OctetStreamParser, OctetStream_default;
var init_OctetStream = __esm({
  "node_modules/formidable/src/parsers/OctetStream.js"() {
    import_node_stream = __toESM(require_node_stream(), 1);
    OctetStreamParser = class extends import_node_stream.PassThrough {
      constructor(options = {}) {
        super();
        this.globalOptions = { ...options };
      }
    };
    OctetStream_default = OctetStreamParser;
  }
});

// node_modules/formidable/src/plugins/octetstream.js
function plugin(formidable2, options) {
  const self2 = this || formidable2;
  if (/octet-stream/i.test(self2.headers["content-type"])) {
    init.call(self2, self2, options);
  }
  return self2;
}
function init(_self, _opts) {
  this.type = octetStreamType;
  const originalFilename = this.headers["x-file-name"];
  const mimetype = this.headers["content-type"];
  const thisPart = {
    originalFilename,
    mimetype
  };
  const newFilename = this._getNewName(thisPart);
  const filepath = this._joinDirectoryName(newFilename);
  const file = this._newFile({
    newFilename,
    filepath,
    originalFilename,
    mimetype
  });
  this.emit("fileBegin", originalFilename, file);
  file.open();
  this.openedFiles.push(file);
  this._flushing += 1;
  this._parser = new OctetStream_default(this.options);
  let outstandingWrites = 0;
  this._parser.on("data", (buffer) => {
    this.pause();
    outstandingWrites += 1;
    file.write(buffer, () => {
      outstandingWrites -= 1;
      this.resume();
      if (this.ended) {
        this._parser.emit("doneWritingFile");
      }
    });
  });
  this._parser.on("end", () => {
    this._flushing -= 1;
    this.ended = true;
    const done = () => {
      file.end(() => {
        this.emit("file", "file", file);
        this._maybeEnd();
      });
    };
    if (outstandingWrites === 0) {
      done();
    } else {
      this._parser.once("doneWritingFile", done);
    }
  });
  return this;
}
var octetStreamType;
var init_octetstream = __esm({
  "node_modules/formidable/src/plugins/octetstream.js"() {
    init_OctetStream();
    octetStreamType = "octet-stream";
  }
});

// node_modules/formidable/src/parsers/Querystring.js
var import_node_stream2, QuerystringParser, Querystring_default;
var init_Querystring = __esm({
  "node_modules/formidable/src/parsers/Querystring.js"() {
    import_node_stream2 = __toESM(require_node_stream(), 1);
    QuerystringParser = class extends import_node_stream2.Transform {
      constructor(options = {}) {
        super({ readableObjectMode: true });
        this.globalOptions = { ...options };
        this.buffer = "";
        this.bufferLength = 0;
      }
      _transform(buffer, encoding, callback) {
        this.buffer += buffer.toString("ascii");
        this.bufferLength = this.buffer.length;
        callback();
      }
      _flush(callback) {
        const fields = new URLSearchParams(this.buffer);
        for (const [key, value] of fields) {
          this.push({
            key,
            value
          });
        }
        this.buffer = "";
        callback();
      }
    };
    Querystring_default = QuerystringParser;
  }
});

// node_modules/formidable/src/plugins/querystring.js
function plugin2(formidable2, options) {
  const self2 = this || formidable2;
  if (/urlencoded/i.test(self2.headers["content-type"])) {
    init2.call(self2, self2, options);
  }
  return self2;
}
function init2(_self, _opts) {
  this.type = querystringType;
  const parser = new Querystring_default(this.options);
  parser.on("data", ({ key, value }) => {
    this.emit("field", key, value);
  });
  parser.once("end", () => {
    this.ended = true;
    this._maybeEnd();
  });
  this._parser = parser;
  return this;
}
var querystringType;
var init_querystring = __esm({
  "node_modules/formidable/src/plugins/querystring.js"() {
    init_Querystring();
    querystringType = "urlencoded";
  }
});

// node_modules/formidable/src/FormidableError.js
var FormidableError_exports = {};
__export(FormidableError_exports, {
  aborted: () => aborted,
  biggerThanMaxFileSize: () => biggerThanMaxFileSize,
  biggerThanTotalMaxFileSize: () => biggerThanTotalMaxFileSize,
  default: () => FormidableError_default,
  filenameNotString: () => filenameNotString,
  malformedMultipart: () => malformedMultipart,
  maxFieldsExceeded: () => maxFieldsExceeded,
  maxFieldsSizeExceeded: () => maxFieldsSizeExceeded,
  maxFilesExceeded: () => maxFilesExceeded,
  missingContentType: () => missingContentType,
  missingMultipartBoundary: () => missingMultipartBoundary,
  missingPlugin: () => missingPlugin,
  noEmptyFiles: () => noEmptyFiles,
  noParser: () => noParser,
  pluginFailed: () => pluginFailed,
  pluginFunction: () => pluginFunction,
  smallerThanMinFileSize: () => smallerThanMinFileSize,
  uninitializedParser: () => uninitializedParser,
  unknownTransferEncoding: () => unknownTransferEncoding
});
var missingPlugin, pluginFunction, aborted, noParser, uninitializedParser, filenameNotString, maxFieldsSizeExceeded, maxFieldsExceeded, smallerThanMinFileSize, biggerThanTotalMaxFileSize, noEmptyFiles, missingContentType, malformedMultipart, missingMultipartBoundary, unknownTransferEncoding, maxFilesExceeded, biggerThanMaxFileSize, pluginFailed, FormidableError, FormidableError_default;
var init_FormidableError = __esm({
  "node_modules/formidable/src/FormidableError.js"() {
    missingPlugin = 1e3;
    pluginFunction = 1001;
    aborted = 1002;
    noParser = 1003;
    uninitializedParser = 1004;
    filenameNotString = 1005;
    maxFieldsSizeExceeded = 1006;
    maxFieldsExceeded = 1007;
    smallerThanMinFileSize = 1008;
    biggerThanTotalMaxFileSize = 1009;
    noEmptyFiles = 1010;
    missingContentType = 1011;
    malformedMultipart = 1012;
    missingMultipartBoundary = 1013;
    unknownTransferEncoding = 1014;
    maxFilesExceeded = 1015;
    biggerThanMaxFileSize = 1016;
    pluginFailed = 1017;
    FormidableError = class extends Error {
      constructor(message, internalCode, httpCode = 500) {
        super(message);
        this.code = internalCode;
        this.httpCode = httpCode;
      }
    };
    FormidableError_default = FormidableError;
  }
});

// node_modules/formidable/src/parsers/Multipart.js
function lower(c) {
  return c | 32;
}
var import_node_stream3, s, STATE, f, FBOUNDARY, LF, CR, SPACE, HYPHEN, COLON, A, Z, STATES, MultipartParser, Multipart_default;
var init_Multipart = __esm({
  "node_modules/formidable/src/parsers/Multipart.js"() {
    import_node_stream3 = __toESM(require_node_stream(), 1);
    init_FormidableError();
    init_FormidableError();
    s = 0;
    STATE = {
      PARSER_UNINITIALIZED: s++,
      START: s++,
      START_BOUNDARY: s++,
      HEADER_FIELD_START: s++,
      HEADER_FIELD: s++,
      HEADER_VALUE_START: s++,
      HEADER_VALUE: s++,
      HEADER_VALUE_ALMOST_DONE: s++,
      HEADERS_ALMOST_DONE: s++,
      PART_DATA_START: s++,
      PART_DATA: s++,
      PART_END: s++,
      END: s++
    };
    f = 1;
    FBOUNDARY = { PART_BOUNDARY: f, LAST_BOUNDARY: f *= 2 };
    LF = 10;
    CR = 13;
    SPACE = 32;
    HYPHEN = 45;
    COLON = 58;
    A = 97;
    Z = 122;
    STATES = {};
    Object.keys(STATE).forEach((stateName) => {
      STATES[stateName] = STATE[stateName];
    });
    MultipartParser = class extends import_node_stream3.Transform {
      constructor(options = {}) {
        super({ readableObjectMode: true });
        this.boundary = null;
        this.boundaryChars = null;
        this.lookbehind = null;
        this.bufferLength = 0;
        this.state = STATE.PARSER_UNINITIALIZED;
        this.globalOptions = { ...options };
        this.index = null;
        this.flags = 0;
      }
      _flush(done) {
        if (this.state === STATE.HEADER_FIELD_START && this.index === 0 || this.state === STATE.PART_DATA && this.index === this.boundary.length) {
          this._handleCallback("partEnd");
          this._handleCallback("end");
          done();
        } else if (this.state !== STATE.END) {
          done(
            new FormidableError_default(
              `MultipartParser.end(): stream ended unexpectedly: ${this.explain()}`,
              malformedMultipart,
              400
            )
          );
        }
      }
      initWithBoundary(str) {
        this.boundary = Buffer.from(`\r
--${str}`);
        this.lookbehind = Buffer.alloc(this.boundary.length + 8);
        this.state = STATE.START;
        this.boundaryChars = {};
        for (let i = 0; i < this.boundary.length; i++) {
          this.boundaryChars[this.boundary[i]] = true;
        }
      }
      _handleCallback(name, buf, start, end) {
        if (start !== void 0 && start === end) {
          return;
        }
        this.push({ name, buffer: buf, start, end });
      }
      _transform(buffer, _, done) {
        let i = 0;
        let prevIndex = this.index;
        let { index, state, flags } = this;
        const { lookbehind, boundary, boundaryChars } = this;
        const boundaryLength = boundary.length;
        const boundaryEnd = boundaryLength - 1;
        this.bufferLength = buffer.length;
        let c = null;
        let cl = null;
        const setMark = (name, idx) => {
          this[`${name}Mark`] = typeof idx === "number" ? idx : i;
        };
        const clearMarkSymbol = (name) => {
          delete this[`${name}Mark`];
        };
        const dataCallback = (name, shouldClear) => {
          const markSymbol = `${name}Mark`;
          if (!(markSymbol in this)) {
            return;
          }
          if (!shouldClear) {
            this._handleCallback(name, buffer, this[markSymbol], buffer.length);
            setMark(name, 0);
          } else {
            this._handleCallback(name, buffer, this[markSymbol], i);
            clearMarkSymbol(name);
          }
        };
        for (i = 0; i < this.bufferLength; i++) {
          c = buffer[i];
          switch (state) {
            case STATE.PARSER_UNINITIALIZED:
              return i;
            case STATE.START:
              index = 0;
              state = STATE.START_BOUNDARY;
            case STATE.START_BOUNDARY:
              if (index === boundary.length - 2) {
                if (c === HYPHEN) {
                  flags |= FBOUNDARY.LAST_BOUNDARY;
                } else if (c !== CR) {
                  return i;
                }
                index++;
                break;
              } else if (index - 1 === boundary.length - 2) {
                if (flags & FBOUNDARY.LAST_BOUNDARY && c === HYPHEN) {
                  this._handleCallback("end");
                  state = STATE.END;
                  flags = 0;
                } else if (!(flags & FBOUNDARY.LAST_BOUNDARY) && c === LF) {
                  index = 0;
                  this._handleCallback("partBegin");
                  state = STATE.HEADER_FIELD_START;
                } else {
                  return i;
                }
                break;
              }
              if (c !== boundary[index + 2]) {
                index = -2;
              }
              if (c === boundary[index + 2]) {
                index++;
              }
              break;
            case STATE.HEADER_FIELD_START:
              state = STATE.HEADER_FIELD;
              setMark("headerField");
              index = 0;
            case STATE.HEADER_FIELD:
              if (c === CR) {
                clearMarkSymbol("headerField");
                state = STATE.HEADERS_ALMOST_DONE;
                break;
              }
              index++;
              if (c === HYPHEN) {
                break;
              }
              if (c === COLON) {
                if (index === 1) {
                  return i;
                }
                dataCallback("headerField", true);
                state = STATE.HEADER_VALUE_START;
                break;
              }
              cl = lower(c);
              if (cl < A || cl > Z) {
                return i;
              }
              break;
            case STATE.HEADER_VALUE_START:
              if (c === SPACE) {
                break;
              }
              setMark("headerValue");
              state = STATE.HEADER_VALUE;
            case STATE.HEADER_VALUE:
              if (c === CR) {
                dataCallback("headerValue", true);
                this._handleCallback("headerEnd");
                state = STATE.HEADER_VALUE_ALMOST_DONE;
              }
              break;
            case STATE.HEADER_VALUE_ALMOST_DONE:
              if (c !== LF) {
                return i;
              }
              state = STATE.HEADER_FIELD_START;
              break;
            case STATE.HEADERS_ALMOST_DONE:
              if (c !== LF) {
                return i;
              }
              this._handleCallback("headersEnd");
              state = STATE.PART_DATA_START;
              break;
            case STATE.PART_DATA_START:
              state = STATE.PART_DATA;
              setMark("partData");
            case STATE.PART_DATA:
              prevIndex = index;
              if (index === 0) {
                i += boundaryEnd;
                while (i < this.bufferLength && !(buffer[i] in boundaryChars)) {
                  i += boundaryLength;
                }
                i -= boundaryEnd;
                c = buffer[i];
              }
              if (index < boundary.length) {
                if (boundary[index] === c) {
                  if (index === 0) {
                    dataCallback("partData", true);
                  }
                  index++;
                } else {
                  index = 0;
                }
              } else if (index === boundary.length) {
                index++;
                if (c === CR) {
                  flags |= FBOUNDARY.PART_BOUNDARY;
                } else if (c === HYPHEN) {
                  flags |= FBOUNDARY.LAST_BOUNDARY;
                } else {
                  index = 0;
                }
              } else if (index - 1 === boundary.length) {
                if (flags & FBOUNDARY.PART_BOUNDARY) {
                  index = 0;
                  if (c === LF) {
                    flags &= ~FBOUNDARY.PART_BOUNDARY;
                    this._handleCallback("partEnd");
                    this._handleCallback("partBegin");
                    state = STATE.HEADER_FIELD_START;
                    break;
                  }
                } else if (flags & FBOUNDARY.LAST_BOUNDARY) {
                  if (c === HYPHEN) {
                    this._handleCallback("partEnd");
                    this._handleCallback("end");
                    state = STATE.END;
                    flags = 0;
                  } else {
                    index = 0;
                  }
                } else {
                  index = 0;
                }
              }
              if (index > 0) {
                lookbehind[index - 1] = c;
              } else if (prevIndex > 0) {
                this._handleCallback("partData", lookbehind, 0, prevIndex);
                prevIndex = 0;
                setMark("partData");
                i--;
              }
              break;
            case STATE.END:
              break;
            default:
              return i;
          }
        }
        dataCallback("headerField");
        dataCallback("headerValue");
        dataCallback("partData");
        this.index = index;
        this.state = state;
        this.flags = flags;
        done();
        return this.bufferLength;
      }
      explain() {
        return `state = ${MultipartParser.stateToString(this.state)}`;
      }
    };
    MultipartParser.stateToString = (stateNumber) => {
      for (const stateName in STATE) {
        const number = STATE[stateName];
        if (number === stateNumber)
          return stateName;
      }
    };
    Multipart_default = Object.assign(MultipartParser, { STATES });
  }
});

// node_modules/formidable/src/plugins/multipart.js
function plugin3(formidable2, options) {
  const self2 = this || formidable2;
  const multipart = /multipart/i.test(self2.headers["content-type"]);
  if (multipart) {
    const m = self2.headers["content-type"].match(
      /boundary=(?:"([^"]+)"|([^;]+))/i
    );
    if (m) {
      const initMultipart = createInitMultipart(m[1] || m[2]);
      initMultipart.call(self2, self2, options);
    } else {
      const err = new FormidableError_default(
        "bad content-type header, no multipart boundary",
        missingMultipartBoundary,
        400
      );
      self2._error(err);
    }
  }
  return self2;
}
function createInitMultipart(boundary) {
  return function initMultipart() {
    this.type = multipartType;
    const parser = new Multipart_default(this.options);
    let headerField;
    let headerValue;
    let part;
    parser.initWithBoundary(boundary);
    parser.on("data", ({ name, buffer, start, end }) => {
      if (name === "partBegin") {
        part = new import_node_stream4.Stream();
        part.readable = true;
        part.headers = {};
        part.name = null;
        part.originalFilename = null;
        part.mimetype = null;
        part.transferEncoding = this.options.encoding;
        part.transferBuffer = "";
        headerField = "";
        headerValue = "";
      } else if (name === "headerField") {
        headerField += buffer.toString(this.options.encoding, start, end);
      } else if (name === "headerValue") {
        headerValue += buffer.toString(this.options.encoding, start, end);
      } else if (name === "headerEnd") {
        headerField = headerField.toLowerCase();
        part.headers[headerField] = headerValue;
        const m = headerValue.match(
          /\bname=("([^"]*)"|([^\(\)<>@,;:\\"\/\[\]\?=\{\}\s\t/]+))/i
        );
        if (headerField === "content-disposition") {
          if (m) {
            part.name = m[2] || m[3] || "";
          }
          part.originalFilename = this._getFileName(headerValue);
        } else if (headerField === "content-type") {
          part.mimetype = headerValue;
        } else if (headerField === "content-transfer-encoding") {
          part.transferEncoding = headerValue.toLowerCase();
        }
        headerField = "";
        headerValue = "";
      } else if (name === "headersEnd") {
        switch (part.transferEncoding) {
          case "binary":
          case "7bit":
          case "8bit":
          case "utf-8": {
            const dataPropagation = (ctx) => {
              if (ctx.name === "partData") {
                part.emit("data", ctx.buffer.slice(ctx.start, ctx.end));
              }
            };
            const dataStopPropagation = (ctx) => {
              if (ctx.name === "partEnd") {
                part.emit("end");
                parser.off("data", dataPropagation);
                parser.off("data", dataStopPropagation);
              }
            };
            parser.on("data", dataPropagation);
            parser.on("data", dataStopPropagation);
            break;
          }
          case "base64": {
            const dataPropagation = (ctx) => {
              if (ctx.name === "partData") {
                part.transferBuffer += ctx.buffer.slice(ctx.start, ctx.end).toString("ascii");
                const offset = parseInt(part.transferBuffer.length / 4, 10) * 4;
                part.emit(
                  "data",
                  Buffer.from(
                    part.transferBuffer.substring(0, offset),
                    "base64"
                  )
                );
                part.transferBuffer = part.transferBuffer.substring(offset);
              }
            };
            const dataStopPropagation = (ctx) => {
              if (ctx.name === "partEnd") {
                part.emit("data", Buffer.from(part.transferBuffer, "base64"));
                part.emit("end");
                parser.off("data", dataPropagation);
                parser.off("data", dataStopPropagation);
              }
            };
            parser.on("data", dataPropagation);
            parser.on("data", dataStopPropagation);
            break;
          }
          default:
            return this._error(
              new FormidableError_default(
                "unknown transfer-encoding",
                unknownTransferEncoding,
                501
              )
            );
        }
        this.onPart(part);
      } else if (name === "end") {
        this.ended = true;
        this._maybeEnd();
      }
    });
    this._parser = parser;
  };
}
var import_node_stream4, multipartType;
var init_multipart = __esm({
  "node_modules/formidable/src/plugins/multipart.js"() {
    import_node_stream4 = __toESM(require_node_stream(), 1);
    init_Multipart();
    init_FormidableError();
    init_FormidableError();
    multipartType = "multipart";
  }
});

// node_modules/formidable/src/parsers/JSON.js
var import_node_stream5, JSONParser, JSON_default;
var init_JSON = __esm({
  "node_modules/formidable/src/parsers/JSON.js"() {
    import_node_stream5 = __toESM(require_node_stream(), 1);
    JSONParser = class extends import_node_stream5.Transform {
      constructor(options = {}) {
        super({ readableObjectMode: true });
        this.chunks = [];
        this.globalOptions = { ...options };
      }
      _transform(chunk, encoding, callback) {
        this.chunks.push(String(chunk));
        callback();
      }
      _flush(callback) {
        try {
          const fields = JSON.parse(this.chunks.join(""));
          this.push(fields);
        } catch (e) {
          callback(e);
          return;
        }
        this.chunks = null;
        callback();
      }
    };
    JSON_default = JSONParser;
  }
});

// node_modules/formidable/src/plugins/json.js
function plugin4(formidable2, options) {
  const self2 = this || formidable2;
  if (/json/i.test(self2.headers["content-type"])) {
    init3.call(self2, self2, options);
  }
  return self2;
}
function init3(_self, _opts) {
  this.type = jsonType;
  const parser = new JSON_default(this.options);
  parser.on("data", (fields) => {
    this.fields = fields;
  });
  parser.once("end", () => {
    this.ended = true;
    this._maybeEnd();
  });
  this._parser = parser;
}
var jsonType;
var init_json = __esm({
  "node_modules/formidable/src/plugins/json.js"() {
    init_JSON();
    jsonType = "json";
  }
});

// node_modules/formidable/src/plugins/index.js
var init_plugins = __esm({
  "node_modules/formidable/src/plugins/index.js"() {
    init_octetstream();
    init_querystring();
    init_multipart();
    init_json();
  }
});

// node_modules/formidable/src/parsers/Dummy.js
var import_node_stream6, DummyParser, Dummy_default;
var init_Dummy = __esm({
  "node_modules/formidable/src/parsers/Dummy.js"() {
    import_node_stream6 = __toESM(require_node_stream(), 1);
    DummyParser = class extends import_node_stream6.Transform {
      constructor(incomingForm, options = {}) {
        super();
        this.globalOptions = { ...options };
        this.incomingForm = incomingForm;
      }
      _flush(callback) {
        this.incomingForm.ended = true;
        this.incomingForm._maybeEnd();
        callback();
      }
    };
    Dummy_default = DummyParser;
  }
});

// node_modules/formidable/src/Formidable.js
function hasOwnProp(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
var import_node_os, import_node_path, import_node_events3, import_node_string_decoder, import_once, import_dezalgo, toHexoId, DEFAULT_OPTIONS, invalidExtensionChar, IncomingForm, Formidable_default;
var init_Formidable = __esm({
  "node_modules/formidable/src/Formidable.js"() {
    import_node_os = __toESM(require_node_os(), 1);
    import_node_path = __toESM(require_node_path(), 1);
    import_node_events3 = __toESM(require_node_events(), 1);
    import_node_string_decoder = __toESM(require_node_string_decoder(), 1);
    init_dist();
    import_once = __toESM(require_once(), 1);
    import_dezalgo = __toESM(require_dezalgo(), 1);
    init_plugins();
    init_PersistentFile();
    init_VolatileFile();
    init_Dummy();
    init_Multipart();
    init_FormidableError();
    init_FormidableError();
    toHexoId = dist_default(25);
    DEFAULT_OPTIONS = {
      maxFields: 1e3,
      maxFieldsSize: 20 * 1024 * 1024,
      maxFiles: Infinity,
      maxFileSize: 200 * 1024 * 1024,
      maxTotalFileSize: void 0,
      minFileSize: 1,
      allowEmptyFiles: false,
      keepExtensions: false,
      encoding: "utf-8",
      hashAlgorithm: false,
      uploadDir: import_node_os.default.tmpdir(),
      enabledPlugins: [plugin, plugin2, plugin3, plugin4],
      fileWriteStreamHandler: null,
      defaultInvalidName: "invalid-name",
      filter(_part) {
        return true;
      },
      filename: void 0
    };
    invalidExtensionChar = (c) => {
      const code = c.charCodeAt(0);
      return !(code === 46 || code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122);
    };
    IncomingForm = class extends import_node_events3.EventEmitter {
      constructor(options = {}) {
        super();
        this.options = { ...DEFAULT_OPTIONS, ...options };
        if (!this.options.maxTotalFileSize) {
          this.options.maxTotalFileSize = this.options.maxFileSize;
        }
        const dir = import_node_path.default.resolve(
          this.options.uploadDir || this.options.uploaddir || import_node_os.default.tmpdir()
        );
        this.uploaddir = dir;
        this.uploadDir = dir;
        [
          "error",
          "headers",
          "type",
          "bytesExpected",
          "bytesReceived",
          "_parser",
          "req"
        ].forEach((key) => {
          this[key] = null;
        });
        this._setUpRename();
        this._flushing = 0;
        this._fieldsSize = 0;
        this._totalFileSize = 0;
        this._plugins = [];
        this.openedFiles = [];
        this.options.enabledPlugins = [].concat(this.options.enabledPlugins).filter(Boolean);
        if (this.options.enabledPlugins.length === 0) {
          throw new FormidableError_default(
            "expect at least 1 enabled builtin plugin, see options.enabledPlugins",
            missingPlugin
          );
        }
        this.options.enabledPlugins.forEach((plugin5) => {
          this.use(plugin5);
        });
        this._setUpMaxFields();
        this._setUpMaxFiles();
        this.ended = void 0;
        this.type = void 0;
      }
      use(plugin5) {
        if (typeof plugin5 !== "function") {
          throw new FormidableError_default(
            ".use: expect `plugin` to be a function",
            pluginFunction
          );
        }
        this._plugins.push(plugin5.bind(this));
        return this;
      }
      pause() {
        try {
          this.req.pause();
        } catch (err) {
          if (!this.ended) {
            this._error(err);
          }
          return false;
        }
        return true;
      }
      resume() {
        try {
          this.req.resume();
        } catch (err) {
          if (!this.ended) {
            this._error(err);
          }
          return false;
        }
        return true;
      }
      parse(req, cb) {
        this.req = req;
        if (cb) {
          const callback = (0, import_once.default)((0, import_dezalgo.default)(cb));
          this.fields = {};
          const files = {};
          this.on("field", (name, value) => {
            if (this.type === "multipart" || this.type === "urlencoded") {
              if (!hasOwnProp(this.fields, name)) {
                this.fields[name] = [value];
              } else {
                this.fields[name].push(value);
              }
            } else {
              this.fields[name] = value;
            }
          });
          this.on("file", (name, file) => {
            if (!hasOwnProp(files, name)) {
              files[name] = [file];
            } else {
              files[name].push(file);
            }
          });
          this.on("error", (err) => {
            callback(err, this.fields, files);
          });
          this.on("end", () => {
            callback(null, this.fields, files);
          });
        }
        this.writeHeaders(req.headers);
        req.on("error", (err) => {
          this._error(err);
        }).on("aborted", () => {
          this.emit("aborted");
          this._error(new FormidableError_default("Request aborted", aborted));
        }).on("data", (buffer) => {
          try {
            this.write(buffer);
          } catch (err) {
            this._error(err);
          }
        }).on("end", () => {
          if (this.error) {
            return;
          }
          if (this._parser) {
            this._parser.end();
          }
        });
        return this;
      }
      writeHeaders(headers) {
        this.headers = headers;
        this._parseContentLength();
        this._parseContentType();
        if (!this._parser) {
          this._error(
            new FormidableError_default(
              "no parser found",
              noParser,
              415
            )
          );
          return;
        }
        this._parser.once("error", (error) => {
          this._error(error);
        });
      }
      write(buffer) {
        if (this.error) {
          return null;
        }
        if (!this._parser) {
          this._error(
            new FormidableError_default("uninitialized parser", uninitializedParser)
          );
          return null;
        }
        this.bytesReceived += buffer.length;
        this.emit("progress", this.bytesReceived, this.bytesExpected);
        this._parser.write(buffer);
        return this.bytesReceived;
      }
      onPart(part) {
        this._handlePart(part);
      }
      _handlePart(part) {
        if (part.originalFilename && typeof part.originalFilename !== "string") {
          this._error(
            new FormidableError_default(
              `the part.originalFilename should be string when it exists`,
              filenameNotString
            )
          );
          return;
        }
        if (!part.mimetype) {
          let value = "";
          const decoder = new import_node_string_decoder.StringDecoder(
            part.transferEncoding || this.options.encoding
          );
          part.on("data", (buffer) => {
            this._fieldsSize += buffer.length;
            if (this._fieldsSize > this.options.maxFieldsSize) {
              this._error(
                new FormidableError_default(
                  `options.maxFieldsSize (${this.options.maxFieldsSize} bytes) exceeded, received ${this._fieldsSize} bytes of field data`,
                  maxFieldsSizeExceeded,
                  413
                )
              );
              return;
            }
            value += decoder.write(buffer);
          });
          part.on("end", () => {
            this.emit("field", part.name, value);
          });
          return;
        }
        if (!this.options.filter(part)) {
          return;
        }
        this._flushing += 1;
        let fileSize = 0;
        const newFilename = this._getNewName(part);
        const filepath = this._joinDirectoryName(newFilename);
        const file = this._newFile({
          newFilename,
          filepath,
          originalFilename: part.originalFilename,
          mimetype: part.mimetype
        });
        file.on("error", (err) => {
          this._error(err);
        });
        this.emit("fileBegin", part.name, file);
        file.open();
        this.openedFiles.push(file);
        part.on("data", (buffer) => {
          this._totalFileSize += buffer.length;
          fileSize += buffer.length;
          if (this._totalFileSize > this.options.maxTotalFileSize) {
            this._error(
              new FormidableError_default(
                `options.maxTotalFileSize (${this.options.maxTotalFileSize} bytes) exceeded, received ${this._totalFileSize} bytes of file data`,
                biggerThanTotalMaxFileSize,
                413
              )
            );
            return;
          }
          if (buffer.length === 0) {
            return;
          }
          this.pause();
          file.write(buffer, () => {
            this.resume();
          });
        });
        part.on("end", () => {
          if (!this.options.allowEmptyFiles && fileSize === 0) {
            this._error(
              new FormidableError_default(
                `options.allowEmptyFiles is false, file size should be greather than 0`,
                noEmptyFiles,
                400
              )
            );
            return;
          }
          if (fileSize < this.options.minFileSize) {
            this._error(
              new FormidableError_default(
                `options.minFileSize (${this.options.minFileSize} bytes) inferior, received ${fileSize} bytes of file data`,
                smallerThanMinFileSize,
                400
              )
            );
            return;
          }
          if (fileSize > this.options.maxFileSize) {
            this._error(
              new FormidableError_default(
                `options.maxFileSize (${this.options.maxFileSize} bytes), received ${fileSize} bytes of file data`,
                biggerThanMaxFileSize,
                413
              )
            );
            return;
          }
          file.end(() => {
            this._flushing -= 1;
            this.emit("file", part.name, file);
            this._maybeEnd();
          });
        });
      }
      _parseContentType() {
        if (this.bytesExpected === 0) {
          this._parser = new Dummy_default(this, this.options);
          return;
        }
        if (!this.headers["content-type"]) {
          this._error(
            new FormidableError_default(
              "bad content-type header, no content-type",
              missingContentType,
              400
            )
          );
          return;
        }
        new Dummy_default(this, this.options);
        const results = [];
        this._plugins.forEach((plugin5, idx) => {
          let pluginReturn = null;
          try {
            pluginReturn = plugin5(this, this.options) || this;
          } catch (err) {
            const error = new FormidableError_default(
              `plugin on index ${idx} failed with: ${err.message}`,
              pluginFailed,
              500
            );
            error.idx = idx;
            throw error;
          }
          Object.assign(this, pluginReturn);
          this.emit("plugin", idx, pluginReturn);
        });
        this.emit("pluginsResults", results);
      }
      _error(err, eventName = "error") {
        if (this.error || this.ended) {
          return;
        }
        this.req = null;
        this.error = err;
        this.emit(eventName, err);
        this.openedFiles.forEach((file) => {
          file.destroy();
        });
      }
      _parseContentLength() {
        this.bytesReceived = 0;
        if (this.headers["content-length"]) {
          this.bytesExpected = parseInt(this.headers["content-length"], 10);
        } else if (this.headers["transfer-encoding"] === void 0) {
          this.bytesExpected = 0;
        }
        if (this.bytesExpected !== null) {
          this.emit("progress", this.bytesReceived, this.bytesExpected);
        }
      }
      _newParser() {
        return new Multipart_default(this.options);
      }
      _newFile({ filepath, originalFilename, mimetype, newFilename }) {
        return this.options.fileWriteStreamHandler ? new VolatileFile_default({
          newFilename,
          filepath,
          originalFilename,
          mimetype,
          createFileWriteStream: this.options.fileWriteStreamHandler,
          hashAlgorithm: this.options.hashAlgorithm
        }) : new PersistentFile_default({
          newFilename,
          filepath,
          originalFilename,
          mimetype,
          hashAlgorithm: this.options.hashAlgorithm
        });
      }
      _getFileName(headerValue) {
        const m = headerValue.match(
          /\bfilename=("(.*?)"|([^()<>{}[\]@,;:"?=\s/\t]+))($|;\s)/i
        );
        if (!m)
          return null;
        const match = m[2] || m[3] || "";
        let originalFilename = match.substr(match.lastIndexOf("\\") + 1);
        originalFilename = originalFilename.replace(/%22/g, '"');
        originalFilename = originalFilename.replace(
          /&#([\d]{4});/g,
          (_, code) => String.fromCharCode(code)
        );
        return originalFilename;
      }
      _getExtension(str) {
        if (!str) {
          return "";
        }
        const basename = import_node_path.default.basename(str);
        const firstDot = basename.indexOf(".");
        const lastDot = basename.lastIndexOf(".");
        let rawExtname = import_node_path.default.extname(basename);
        if (firstDot !== lastDot) {
          rawExtname = basename.slice(firstDot);
        }
        let filtered;
        const firstInvalidIndex = Array.from(rawExtname).findIndex(invalidExtensionChar);
        if (firstInvalidIndex === -1) {
          filtered = rawExtname;
        } else {
          filtered = rawExtname.substring(0, firstInvalidIndex);
        }
        if (filtered === ".") {
          return "";
        }
        return filtered;
      }
      _joinDirectoryName(name) {
        const newPath = import_node_path.default.join(this.uploadDir, name);
        if (!newPath.startsWith(this.uploadDir)) {
          return import_node_path.default.join(this.uploadDir, this.options.defaultInvalidName);
        }
        return newPath;
      }
      _setUpRename() {
        const hasRename = typeof this.options.filename === "function";
        if (hasRename) {
          this._getNewName = (part) => {
            let ext = "";
            let name = this.options.defaultInvalidName;
            if (part.originalFilename) {
              ({ ext, name } = import_node_path.default.parse(part.originalFilename));
              if (this.options.keepExtensions !== true) {
                ext = "";
              }
            }
            return this.options.filename.call(this, name, ext, part, this);
          };
        } else {
          this._getNewName = (part) => {
            const name = toHexoId();
            if (part && this.options.keepExtensions) {
              const originalFilename = typeof part === "string" ? part : part.originalFilename;
              return `${name}${this._getExtension(originalFilename)}`;
            }
            return name;
          };
        }
      }
      _setUpMaxFields() {
        if (this.options.maxFields !== Infinity) {
          let fieldsCount = 0;
          this.on("field", () => {
            fieldsCount += 1;
            if (fieldsCount > this.options.maxFields) {
              this._error(
                new FormidableError_default(
                  `options.maxFields (${this.options.maxFields}) exceeded`,
                  maxFieldsExceeded,
                  413
                )
              );
            }
          });
        }
      }
      _setUpMaxFiles() {
        if (this.options.maxFiles !== Infinity) {
          let fileCount = 0;
          this.on("fileBegin", () => {
            fileCount += 1;
            if (fileCount > this.options.maxFiles) {
              this._error(
                new FormidableError_default(
                  `options.maxFiles (${this.options.maxFiles}) exceeded`,
                  maxFilesExceeded,
                  413
                )
              );
            }
          });
        }
      }
      _maybeEnd() {
        if (!this.ended || this._flushing || this.error) {
          return;
        }
        this.req = null;
        this.emit("end");
      }
    };
    Formidable_default = IncomingForm;
  }
});

// node_modules/formidable/src/parsers/index.js
var init_parsers = __esm({
  "node_modules/formidable/src/parsers/index.js"() {
    init_JSON();
    init_Dummy();
    init_Multipart();
    init_OctetStream();
    init_Querystring();
  }
});

// node_modules/formidable/src/index.js
var formidable, enabledPlugins, src_default;
var init_src = __esm({
  "node_modules/formidable/src/index.js"() {
    init_PersistentFile();
    init_VolatileFile();
    init_Formidable();
    init_parsers();
    init_plugins();
    init_FormidableError();
    formidable = (...args) => new Formidable_default(...args);
    ({ enabledPlugins } = DEFAULT_OPTIONS);
    src_default = formidable;
  }
});
init_src();
export {
  Dummy_default as DummyParser,
  PersistentFile_default as File,
  Formidable_default as Formidable,
  Formidable_default as IncomingForm,
  JSON_default as JSONParser,
  Multipart_default as MultipartParser,
  OctetStream_default as OctetStreamParser,
  OctetStream_default as OctetstreamParser,
  PersistentFile_default as PersistentFile,
  Querystring_default as QueryStringParser,
  Querystring_default as QuerystringParser,
  VolatileFile_default as VolatileFile,
  src_default as default,
  DEFAULT_OPTIONS as defaultOptions,
  enabledPlugins,
  FormidableError_exports as errors,
  formidable,
  plugin4 as json,
  plugin3 as multipart,
  plugin as octetstream,
  plugin2 as querystring
};
//# sourceMappingURL=src-LPYMV5BC.js.map
